
/** 
 *  SUM_ARRAY HUFF EXERCISE
 *
 * In this puzzle, the task is to simulate an array in Huff using the "exact" storage pattern as solidity. Expected functions can; 
 *      - Push numbers onto a array, 
 *      - Pop the last index from the array,
 *      - View what's stored at an index, 
 *      - Gets the length of the array, 
 *      - Write to an index if it is valid.
 *
 *      - Writes and reads outside of length revert. 
 *      - Popping off a zero length array reverts.
 *
 *  NOTICE: The contract should revert when an unrecognized function is called
 */

 #define function pushh(uint256 num) payable returns()
 #define function popp() payable returns()
 #define function read(uint256 index) payable returns(uint256)
 #define function length() payable returns(uint256)
 #define function write(uint256 index, uint256 num) payable returns()

 #define error OutOfBounds()
 #define error ZeroArray()

 #define constant VALUE = FREE_STORAGE_POINTER() // length

 #define macro MAIN() = takes(0) returns(0) {
	0x00 calldataload 0xE0 shr
	dup1 0x5edfe85d eq pushh jumpi
	dup1 0x6a57dbc7 eq popp jumpi
	dup1 0xed2e5a97 eq read jumpi
	dup1 0x1f7b6d32 eq length jumpi
	0x9c0e3f7a eq write jumpi

    0x00 0x00 revert

	pushh:
		PUSHH()
	popp:
		POPP()
	read:
		READ()
	length:
		LENGTH()
	write:
		WRITE()
 }

 #define macro PUSHH() = takes(0) returns(0) {
    [VALUE]
    sload
    0x01 add
    dup1 [VALUE] sstore
    0x04 calldataload swap1 sstore
    stop
 }

 #define macro POPP() = takes(0) returns(0) {
    [VALUE]
    sload
    dup1 iszero zeroArray jumpi
    0x01 swap1 sub [VALUE] sstore
    stop
    zeroArray:
        __ERROR(ZeroArray) 0x00 mstore
        0x04 0x00 revert
 }

 #define macro READ() = takes(0) returns(0) {
    0x04 calldataload
    0x01 add
    dup1 
    [VALUE]
    sload
    lt outOfBounds jumpi
    sload
    0x0 mstore
    0x20 0x0 return
    outOfBounds:
        __ERROR(OutOfBounds) 0x00 mstore
        0x04 0x00 revert
 }

 #define macro LENGTH() = takes(0) returns(0) {
    [VALUE]
    sload
    0x0 mstore
    0x20 0x0 return
 }

 #define macro WRITE() = takes(0) returns(0) {
    0x24 calldataload 
    0x04 calldataload
    0x01 add
    dup1 
    [VALUE]
    sload
    lt outOfBounds jumpi
    sstore
    stop
    outOfBounds:
        __ERROR(OutOfBounds) 0x00 mstore
        0x04 0x00 revert
 }